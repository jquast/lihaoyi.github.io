<html><head><meta charset="utf-8" /><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" /><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/github-gist.min.css" rel="stylesheet" type="text/css" /><title>Strategic Scala Style: Conciseness &amp; Names</title><style>@media (min-width: 48em) {.cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-header{
  bottom: 0px;
  justify-content: center;
  position: fixed;
  top: 0px;
  width: 25%;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-headerContent{
  text-align: center;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-content{
  box-sizing: border-box;
  margin-left: 25%;
  padding: 48px;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-footer{
  bottom: 0px;
  height: 50px;
  position: fixed;
  width: 25%;
}
}</style><style>@media (max-width: 48em) {.cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-header{
  margin-bottom: 10px;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-content{
  padding: 16px;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-headerContent{
  display: flex;
  flex-direction: row;
  width: 100%;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-linkFlex{
  align-self: flex-end;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-flexFont{
  font-size: 4vw;
}
}</style><style>.cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-header{
  align-items: center;
  background-color: rgb(61, 79, 93);
  box-sizing: border-box;
  display: flex;
  padding: 20px;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-headerLinkBox{
  display: flex;
  flex: 1;
  flex-direction: row;
  text-align: center;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-headerLink{
  align-items: center;
  display: flex;
  flex: 1;
  justify-content: center;
  padding: 10px 10px;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-footer{
  color: rgb(158, 167, 174);
  display: flex;
  justify-content: center;
}

.cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-subtleLink{
  text-decoration: none;
}
</style><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/languages/scala.min.js"></script><script>hljs.initHighlightingOnLoad();</script><meta name="viewport" content="initial-scale = 1.0,maximum-scale = 1.0" /><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-27464920-5', 'auto');
ga('send', 'pageview');
</script><script>if (window.location.protocol == "https:")
    window.location.href = "http:" + window.location.href.substring(window.location.protocol.length);
</script></head><body style="margin: 0px;"><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-header cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-header cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-header"><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-headerContent cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-headerContent"><h1 style="padding: 10px 10px;margin: 0px;"><a style="color: white;font-weight: bold;" href=".." class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-subtleLink cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-flexFont"><i class="fa fa-cogs"></i> Haoyi's Programming Blog</a></h1><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-headerLinkBox cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-linkFlex"><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-headerLink"><a href="../post/HelloWorldBlog.html" class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-subtleLink" style="color: white;"><div><div><i class="fa fa-question-circle"></i></div> About</div></a></div><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-headerLink"><a href="https://lihaoyi.github.io/Resume/" class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-subtleLink" style="color: white;"><div><div><i class="fa fa-file-text-o"></i></div> Resume</div></a></div><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-headerLink"><a href="https://github.com/lihaoyi" class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-subtleLink" style="color: white;"><div><div><i class="fa fa-github"></i></div> Github</div></a></div></div></div></div><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-content cache6e734f883e5a972fd8c15f0a7a2b05ec-NarrowStyles-content" style="max-width: 900px;"><h1>Strategic Scala Style: Conciseness &amp; Names</h1><div style="color: #999;margin-bottom: 20px;">Posted <a href="https://github.com/lihaoyi/blog/commit/d37784a1302eafd80a6a07ab573092bb16c25538">2016-02-22</a></div><p>"Naming things" is one of those traditionally "hard problems" in software engineering. The Scala programming language gives you more tools than most languages do to manage names: apart from picking alphanumeric names of arbitrary length, you can also name things using operators, or in many cases not names things at all using language features like <code>apply</code> or the <code>_</code> placeholder parameter.</p>
<p>However, the fact that code ends up "too concise" is itself one of the most common complaints leveled against the Scala programming language. How can we pick the right balance of verbosity and conciseness, at the right times, to ensure future maintainers of our software do not end up hating us?</p>
<hr/>
<p>This post is part of a series, following an earlier post <a href="https://lihaoyi.github.io/post/StrategicScalaStylePrincipleofLeastPower.html">Strategic Scala Style: Principle of Least Power</a>. Like that post, this assumes you are already proficient in the Scala programming language: you are already familiar with most of its features, and how to use them. This post will thus entirely skip-over the</p>
<blockquote>
  <p>When <em>can</em> you use short names?</p>
</blockquote>
<p>And instead focus on the follow-up question</p>
<blockquote>
  <p>When <em>should</em> you use short names?</p>
</blockquote>
<p>Similar to the earlier post, this covers a wide-range of topics, and is focused on the "Vanilla Scala" use case. It's unlikely that everyone will agree with every point, especially those using specialized libraries, but hopefully people will find it broadly agreeable and be able to use it as a framework to insert whatever team-specific guidelines or conventions they prefer.</p>
<p>Here's an overview of the philosophy</p>
<ul>
  <li><strong><a href="#Philosophy">Philosophy</a></strong>
    <ul>
      <li><a href="#conciseness-not-for-writing-but-for-reading">Conciseness: not for Writing, but for Reading</a></li>
      <li><a href="#huffman-encoding">Huffman Encoding</a></li>
      <li><a href="#human-languages">Human Languages</a></li>
      <li><a href="#Extremes">Extremes</a></li>
    </ul>
  </li>
</ul>
<p>And guidelines:</p>
<ul>
  <li><strong><a href="#long-names-vs-short-names">Long Names vs Short Names</a></strong>
    <ul>
      <li><a href="#wider-scoped-names-should-be-longer">Wider scoped names should be Longer</a></li>
      <li><a href="#more-used-names-should-be-shorter">More used names should be Shorter</a></li>
      <li><a href="#dangerous-names-should-be-longer">Dangerous names should be Longer</a></li>
      <li><a href="#names-with-source-context-should-be-shorter">Names with source context should be Shorter</a></li>
      <li><a href="#strongly-typed-names-should-be-shorter">Strongly-typed names should be Shorter</a></li>
    </ul>
  </li>
  <li><strong><a href="#degenerate-names">Degenerate Names</a></strong>
    <ul>
      <li><a href="#when-to-use-operators">When to use operators?</a></li>
      <li><a href="#when-to-name-methods-apply">When to name methods "apply"</a></li>
      <li><a href="#when-to-use-the-_-underscore-argument">When to use the _ Underscore Argument?</a></li>
    </ul>
  </li>
  <li><strong><a href="#how-do-you-judge-names-in-a-library">How do you judge names in a library?</a></strong>
    <ul>
      <li><a href="#if-you-are-the-library-author">If you are the library author</a></li>
      <li><a href="#if-you-are-the-library-user">If you are the library user</a></li>
    </ul>
  </li>
  <li><strong><a href="#case-studies">Case Studies</a></strong>
    <ul>
      <li><a href="#case-study-scalaz">Scalaz</a></li>
      <li><a href="#case-study-parser-combinators">Parser Combinators</a></li>
      <li><a href="#case-study-http">HTTP</a></li>
    </ul>
  </li>
</ul><h2 id="philosophy">Philosophy</h2>
<p>The basic approach to conciseness and boilerplate can be boiled down to the following:</p>
<blockquote>
  <p>Show programmers something they don't already know, but want to know</p>
</blockquote>
<p>This isn't as flippant as it at first seems: <em>knowing</em> something isn't all-or-nothing, and how much you <em>want</em> to know depends on a great many different factors! Nevertheless, while subjective, this isn't a hand-wavy topic at all. There are concrete things that a programmer would already know, and concrete things they would want to know.</p>
<p>Programmers already know:</p>
<ul>
  <li>Things they've seen before in your codebase</li>
  <li>Things they've seen before in other codebases</li>
  <li>Facts they've picked up in previous jobs</li>
</ul>
<p>Programmers want to know about:</p>
<ul>
  <li>Things that affect what they're doing</li>
  <li>Things which they need to understand</li>
  <li>Things they are unfamiliar with</li>
  <li>Things that are especially dangerous, whether due to correctness, security,  performance, etc.</li>
</ul>
<p>This is not comprehensive, but it should give a sense of the things that people do or do-not want to see. While not totally concrete, this list is already pretty actionable! It turns out that you can make judgements based on what a programmer would already know based on:</p>
<ul>
  <li>Who you think the future programmers are going to be? You? Co-workers?</li>
  <li>What are their backgrounds?</li>
  <li>How long will they be working in your codebase?</li>
  <li>How long have they been familiarizing themselves with your <em>FeatureX</em>?</li>
</ul><h3 id="conciseness-not-for-writing-but-for-reading">Conciseness: not for Writing, but for Reading</h3>
<p>People often justify boilerplate by saying "it's easy to write": autocomplete might fill in long names, or even entire class-bodies in modern IDEs. Repeated code is easy to copy &amp; paste.</p>
<p>And that's all true.</p>
<p>Nevertheless, this view overlooks one important point in software engineering: writing code is never the bottleneck!</p>
<p>Rather, time is spent reading code, or debugging misbehaving code. Nothing right now makes <em>reading</em> extra code or <em>debugging</em> extra code as simple as <em>generating</em> it. Sure, you have some amount of code-folding in IDEs and good debuggers, but it still takes a great deal of effort to go through the boilerplate and figure out where the bug is. That means even if you've saved yourself effort generating it via copy &amp; paste or IDE autocomplete, you're simply setting yourself up for suffering later when something goes wrong and you need to hunt down the error.</p>
<p>Although having more concise code lets you fit more things on one screen, the fitting-more-things-on-one-screen is really a minor gain. The real gain is from all the code you don't need to sift through for bugs or typos (even long identifiers can house typos!) or understand while you're working. That is the real gain</p><h3 id="huffman-encoding">Huffman Encoding</h3>
<p>In many ways, the level of conciseness within an application should follow a <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman Tree</a>: the most common things you want to do should be the most concise, while the less common things should be more verbose.</p>
<p>This strategy maximizes the amount of convenience, since you'll spend most of your time doing the more common things, and those will be concise and convenient. For the things used less often, it's less frustrating to deal with a small amount of boilerplate when you need them. Furthermore, this forces you to make an explicit choice to use those less-used less-convenient things, which is often good if they're less-used because they're error-prone, inefficient or otherwise dangerous.</p>
<p>In the end, Huffman encoding and programming code has similar goals: to eliminate meaningless content and convey as much <em>useful</em> information to the reader as possible. Although that's not the <em>only</em> goal of the code you write, it definitely is something to work towards.</p><h3 id="human-languages">Human Languages</h3>
<p>In fact, this reasoning doesn't just apply to <em>programming</em> languages! People using human languages want the same thing, which can be seen in how language evolves over time. For example, starting from:</p>
<blockquote>
  <p>Hello do you want to get dinner together?</p>
</blockquote>
<p>The first thing to go is often the <em>Hello</em>, since it's basically meaningless and doesn't affect the message. If you're more familiar with a person, you may say:</p>
<blockquote>
  <p>Do you want to get dinner together?</p>
</blockquote>
<p>Or you may drop the <em>together</em> or the <em>Do you</em>, since it's usually obvious that we're referring to the implicit <em>me</em> and <em>you</em>. They already know that, so you leave it out:</p>
<blockquote>
  <p>Want to get dinner?</p>
</blockquote>
<p>Note the word <em>usually</em>! If your most common interaction was asking about someone <em>preparing</em> dinner, rather than <em>buying-and-eating</em> it (for example, in family that takes turns cooking) the same shortened phrase would mean something totally different. In such a case, if buying-and-eating dinner together was un-usual, you would expect someone to spell it out in more words. This applies regardless of whether the words are said in person, over online chat, email, or whatever.</p>
<p>As the familiarity increases, you drop even more from the phrase, down to</p>
<blockquote>
  <p>Dinner?</p>
</blockquote>
<p>And finally, if there is sufficient context (for example it's a scheduled thing, or has already been agreed) you may say nothing at all! For example,</p>
<blockquote>
  <p>*poke*</p>
</blockquote>
<p>Would be enough for the other party to know "oh you want to go get dinner together"</p>
<p>As you can see, having varying levels of conciseness isn't a property unique to programming languages. As the <em>computer</em> doesn't care how concise you write your code as long as it runs, the choice is then left to the future maintainer of your code: what does <em>he or she</em> not already know? This takes judgement and context.</p><h3 id="extremes">Extremes</h3>
<p>Like in many things, in the spectrum between ultimate-conciseness and ultimate-boilerplate, the ideal is somewhere in the middle. If you're not convinced of that in principle, here are two examples.</p>
<p>First, here is some Hoon source code from the <a href="https://github.com/urbit/arvo/blob/ca0fc9e70456f27eb85dac312ab7809989df2fb1/arvo/jael.hoon#L85-L95">Urbit</a> project:</p>
<pre><code class="">  ++  bu-ajar
    |=  pax=path
    ^+  +&gt;
    ?~  pax  +&gt;.$
    %=    $
      pax  t.pax
      xap  [i.pax xap]
      fes  [sef fes]
      sef  (fall (~(get by kin.sef) i.pax) *safe)
    ==
  --
</code></pre>
<p>This is written in a language you don't understand, but even for an unknown language, this code is remarkably cryptic. And if you follow the link above, you will see that this is not an unusual piece of code! In fact the entire project has (or used to have) a policy of "All names shall be three-characters, max".</p>
<p>Given how short the names are, it does not give a maintenance programmer any hints to latch onto when trying to figure out the code. Of course, you can probably figure out what everything is by grepping for their definitions and seeing how they're used in other contexts, so it's not totally hopeless. In fact, good IDEs can help with this, easily letting you find usages and definitions. Nevertheless, figuring out how the code works is harder than it needs to be!</p>
<p>At the other extreme, is code which has so much ceremony you don't know where the real logic is. Below is a snippet from the <a href="https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html">Oracle docs</a> showing how to add an event handler in Java:</p>
<pre><code class="java">someObject.addMouseListener(new MouseAdapter() {
    public void mouseClicked(MouseEvent e) {
        System.out.println(&quot;hello&quot;);
    }
});
</code></pre>
<p>Here we have five lines with lots and lots of code, with only a bit of logic buried in the start and middle to do the real work.</p>
<p>This is also hard to read, but for the opposite reason as he Hoon example above: there is so much <em>stuff</em> telling you what is going on, and it's all true, but describing things I dont't care about. I don't <em>care</em> that we are instantiating a <code>MouseAdapter</code>, or that the <code>mouseClicked</code> method is <code>public</code> and <code>void</code>!</p>
<p>Again, it is possibly to get good at scanning this code, and mentally collapsing it down into its "true" meaning: on click, print something. That is such a mechanical operation that IDEs like IntelliJ even do it for you!</p>
<p>Thus, we can see that having too little boilerplate and too much boilerplate are both problematic, but for different reasons. The rest of this post aims to help you find a happy medium between these extremes.</p><h2 id="long-names-vs-short-names">Long Names vs Short Names</h2>
<p>Here's the at-a-glance guidelines for creating identifiers. Whether you are trying to name a class, package, function, method or variable, the same principles apply.</p>
<p>How to decide the length of a name:</p>
<ul>
  <li><a href="#wider-scoped-names-should-be-longer">Wider scoped names should be Longer</a></li>
  <li><a href="#more-used-names-should-be-shorter">More used names should be Shorter</a></li>
  <li><a href="#dangerous-names-should-be-longer">Dangerous names should be Longer</a></li>
  <li><a href="#names-with-source-context-should-be-shorter">Names with source context should be Shorter</a></li>
  <li><a href="#strongly-typed-names-should-be-shorter">Strongly-typed names should be Shorter</a></li>
</ul>
<p>The first and second point are valid separately, but can be combined to give a metric of <em>usage density</em>: how dense are your uses of an API? 5 times in 1 line? 1/5 lines? 1/50? 1/5000? The denser your uses of an API, the shorter the name should be: methods used multiple-times-per-line should consider <a href="#when-to-use-operators">using operators</a>, whereas names used once per 5000 lines can afford to be a bit longer and more verbose.</p>
<p>One interesting observation to make here is the second point: that how you name something is based not just on what that thing is, but how you expect it to be used! That makes perfect sense when you consider the <a href="#Philosophy">Philosophy</a> behind these guidelines:</p>
<ul>
  <li>A name used more gets more familiar, and thus reduces the confusion caused  by conciseness</li>
  <li>A name used more saves more boilerplate, since the reduction in size is  multiplied by the number of usages</li>
</ul>
<p>Nevertheless, it's worth calling out, and we'll return to this point in the <a href="#how-do-you-judge-names-in-a-library">last section of this post</a>.</p>
<p>Note that this section <em>totally ignores</em> what you put into the name! A short name which a maintenance programmer already understands can be more helpful than a long name which he doesn't. Nevertheless, that's a separate topic for discussion: for now I will only discuss the <em>length</em> of the name, treating the understandability of its contents as a black-box.</p><h3 id="wider-scoped-names-should-be-longer">Wider-scoped names should be Longer</h3>
<p>Why is the name <code>i</code> ok in this example:</p>
<pre><code class="scala">object Foo{
  def main(args: Array[String]) = {
    if (...){
      var i = 0
      while(i &lt; 10) i = i * 2
      println(i)
    }
  }
}
</code></pre>
<p>But not in this one?</p>
<pre><code class="scala">// Foo.scala
object Foo{
  var i = 0
}
</code></pre>
<pre><code class="scala">// Bar.scala
object Bar{
  def main(args: Array[String]) = {
    ... i ...
  }
}
</code></pre>
<p>The answer is that in the first case, the name <code>i</code> is only usable in a tiny part of your program. Thus, while it is short and meaningless, at a glance it is relatively easy to see where it comes from. Thus, a programmer looking at <code>i</code> already knows everything there is to know about it: you don't need to teach them! But in the second example, <code>i</code> is used widely, in totally different files. It's probably worth giving it a slightly longer name to make it less mysterious, e.g.</p>
<pre><code class="scala">// Foo.scala
object Foo{
  var usageCount = 0
}
</code></pre>
<pre><code class="scala">// Bar.scala
object Bar{
  def main(args: Array[String]) = {
    ... usageCount ...
  }
}
</code></pre>
<p>Would be better.</p>
<p>Furthermore, note that this doesn't just tell you to avoid global variables with short names, but <em>local</em> variables too, if the <em>local</em> scope is very large! e.g. if <code>i</code> is used in a 1000 line method:</p>
<pre><code class="scala">object Foo{
  def main(args: Array[String]) = {
    if (...){
      var i = 0

      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      300 lines
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      while(i &lt; 10) {
        ...
        ...
        ...
        ...
        ...
        100 lines
        ...
        ...
        ...
        ...
        ...
        val temp = i * 2
        ...
        ...
        ...
        ...
        ...
        100 lines
        ...
        ...
        ...
        ...
        ...
        i = temp
        ...
        ...
        ...
        ...
        ...
        100 lines
        ...
        ...
        ...
        ...
        ...
      }
      ...
      ...
      ...
      ...
      ...
      200 lines
      ...
      ...
      ...
      ...
      ...
      println(i)

      ...
      ...
      ...
      ...
      ...
      200 lines
      ...
      ...
      ...
      ...
      ...
    }
  }
}
</code></pre>
<p>It would be well worth while giving <code>i</code> a longer name!</p><h3 id="more-used-names-should-be-shorter">More-used Names should be Shorter</h3>
<p><code>println</code> is an ok name in this example:</p>
<pre><code class="scala">object Foo{
  println(1)
}
</code></pre>
<p>But <code>cacheIt</code> is a poor name in <em>this</em> example:</p>
<pre><code class="scala">// Foo.scala
object Foo{
  def cacheIt() = {
    ...
  }
}
</code></pre>
<pre><code class="scala">// Bar.scala
import Foo._
object Bar{
  cacheIt() // Only used once
}
</code></pre>
<p>Why?</p>
<p>Because <code>println</code> is a very heavily used name, and so a future maintainer could be expected to know what it means. In this case, part of the reason it's widely used is because it's in the standard library, but even your own methods could achieve this status within a project if they're used a lot, all over the place.</p>
<p>On the other hand, <code>cacheIt</code> is only ever going to be used in one or a few places. Thus, while it's about the same length is <code>println</code>, someone looking later is much less likely to be familiar. Thus it's worth giving it a slightly more verbose name:</p>
<pre><code class="scala">// Foo.scala
object Foo{
  def initializeCache() = {
    ...
  }
}
</code></pre>
<pre><code class="scala">// Bar.scala
import Foo._
object Bar{
  initializeCache() // Only used once
}
</code></pre>
<p>Or using it fully-qualified via</p>
<pre><code class="scala">// Foo.scala
object Foo{
  def init() = {
    ...
  }
}
</code></pre>
<pre><code class="scala">// Bar.scala

object Bar{
  Foo.init() // Only used once
}
</code></pre><h3 id="dangerous-names-should-be-longer">Dangerous Names should be Longer</h3>
<p>This is bad:</p>
<pre><code class="scala">object Foo{
  def loadDataFieldsFromOfflineCache() = {
    ...
  }
}
</code></pre>
<p>Given what it's doing, that's probably too long. Maybe call it <code>loadCache</code> or something. On the other hand, if it's doing something like</p>
<pre><code class="scala">object Foo{
  def dropTablesInProductionDatabase() = {
    ...
  }
}
</code></pre>
<p>In which case, it's ok for it to be that long. It's dangerous! In fact, making it short is probably a bad idea:</p>
<pre><code class="scala">object Foo{
  def drop() = {
   // Drops all your databases in the production environment
   ...
  }
}
</code></pre>
<p>This is <em>not</em> the kind of thing you want to miss during a code-review and accidentally call at runtime!</p>
<p>While you might not worry about someone accidentally calling <code>loadCache</code> at the wrong time, you very much would <em>not</em> want someone calling a tersely-named <code>drop</code> function at the wrong time! In fact, for something this dangerous it may even be worth going through a bit more ceremony:</p>
<pre><code class="scala">object Foo{
  object Unsafe{
    def dropTablesInProductionDatabase(iKnowWhatImDoing: Boolean = false) = {
      assert(
        iKnowWhatImDoing,
        &quot;Are you sure you want to drop the tables in production???&quot;
      )
      ...
    }
  }
}
</code></pre>
<p>And forcing people to call it with <code>Foo.Unsafe.dropTablesInProduction(iKnowWhatImDoing=true)</code>. After all, you shouldn't be doing this often, and when you do you should be double-sure you actually want to do it!</p>
<p>This kind of reasoning applies in many other cases too. For example, in Scala this is part of the standard library, but probably bad:</p>
<pre><code class="scala">val vec: Vector[T] = ...
val list: List[T] = ...

println(vec(12)) // 13th element
println(list(12)) // 13th element
</code></pre>
<p>In a <code>Vector</code>, indexing with an integer is fast and expected. With a <code>List</code>, it can take up to <code>O(n)</code> time to perform that index! Thus indexing on a <code>List</code> is somewhat more "dangerous" than indexing on a <code>Vector</code>: you could easily accidentally end up in quadratic performance, or worse. Better would be if you called them via:</p>
<pre><code class="scala">val vec: Vector[T] = ...
val list: List[T] = ...

println(vec(12)) // 13th element
println(list.slow(12)) // 13th element
</code></pre>
<p>That way, if you are using a <code>List</code>, you can be pretty-sure you won't end up using a "slow" operation unless you really want to. However, <em>if</em> you actually do really want to, they're all these for you to use under the <code>.slow</code> prefix. That way you trade off a tiny bit of convenience for a lot of protection against accidentally doing the "dangerous" thing.</p>
<p>In the first case we defined "dangerous" thing as <em>deleting production databases</em>, while in the second we defined it as <em>O(n) performance you didn't expect</em>, but the general principle applies in many places. If it's likely that a programmer could do something by accident, but sometimes it still needs to be done, provide it but under a longer, slightly-clunkier name so they have to choose to use it consciously.</p><h3 id="names-with-source-context-should-be-shorter">Names with Source-Context should be Shorter</h3>
<p>This is probably not ok:</p>
<pre><code class="scala">package haoyi
case class Str()
case class Obj()
...
</code></pre>
<p>The names <code>Str</code> and <code>Obj</code> clearly mean <code>String</code> and <code>Object</code>, but what are they <em>for</em>? Let's assume the <code>package haoyi</code> tells you nothing. On the other hand, if we made them longer to instead be</p>
<pre><code class="scala">package haoyi
case class JsonStr()
case class JsonObj()
...
</code></pre>
<p>That would tell us something about it! Or better:</p>
<pre><code class="scala">package haoyi
object Json{
  case class Str()
  case class Obj()
  ...
}
</code></pre>
<p>Both of these are better, though I prefer the second.</p>
<p>Why are they both better, even though the last one has names as short as the first? The answer is that where a name "lives" is just as important as what the name "is" when someone comes along later trying to figure things out. If your name is defined in a package, class, or object, <em>even if it is globally available</em>, its source context tells you a lot about.</p>
<p>Both the second and third examples above convey the same information: That the <code>Str</code> and <code>Obj</code> classes are somehow related to <code>Json</code>. The second via longer names, and the third by putting the names somewhere where the context is obvious.</p>
<p>In fact, this is bad:</p>
<pre><code class="scala">package haoyi.json
object Json{
  case class JsonStr()
  case class JsonObj()
  ...
}
</code></pre>
<p>Someone coming along later already knows it's in the <code>haoyi.json</code> package and has something to do with JSON, no need to say it over and over! Just once will do, and it doesn't matter if the idea of <em>Json</em> is part of the name itself or part of its source context.</p><h3 id="strongly-typed-names-should-be-shorter">Strongly-typed names should be Shorter</h3>
<p>This is bad</p>
<pre><code class="scala">object Foo{
  def rotte(): Unit
}
</code></pre>
<p>But this is ok!</p>
<pre><code class="scala">object Foo{
  def tpose[T, N[_] &lt;: Seq[_], M[_] &lt;: Seq[_]](in: M[N[T]]): N[M[T]]
}
</code></pre>
<p>In both cases, the name is short and cryptic. However, in the first example you have entirely no clue what it does! In the second example, you can guess and quite likely be correct.</p>
<p>In general, names are not the only thing that tell you what something is. Other information is available too, and you should control how long your name is to compensate for a lack or a plenty of information from other sources, such as the types. In fact, I'd argue that this is bad:</p>
<pre><code class="scala">object Foo{
  def transposeNestedTraversables[T, N[_] &lt;: Seq[_], M[_] &lt;: Seq[_]](in: M[N[T]]): N[M[T]]
}
</code></pre>
<p>While this is ok:</p>
<pre><code class="scala">def rotateApplicationLogFileOnDisk(): Unit
</code></pre>
<p>Why? Because in <code>transposeNestedTraversables</code> the second-half name is redundant since we already know that it takes nested traversables. But in <code>rotateApplicationLogFileOnDisk</code> the types tell you nothing, so names can be longer.</p>
<p>Everything in Scala is "strongly typed", but some things are more strongly-typed than others. Functions which take no arguments, return no result (<code>Unit</code>), take their input from global-state and produce their output via side-effects are the least "strongly typed" of Scala functions. Variables labelled as <code>Any</code>, or functions taking <code>Any</code> or returning <code>Any</code> are the least "strongly typed" of Scala variables. Avoid using short names for these, since the type is weak enough that the maintenance programmer will lean more heavily on the name when trying to figure out what it's for.</p><h2 id="degenerate-names">Degenerate Names</h2>
<p>Scala provides multiple ways to say "I don't want to give something a name".</p>
<ul>
  <li><a href="#when-to-use-operators">You can name things using meaningless operators</a></li>
  <li><a href="#when-to-name-methods-apply">Name methods <code>apply</code> and call them via <code>foo(bar)</code> instead of <code>foo.methodName(bar)</code></a></li>
  <li><a href="#when-to-use-the-_-underscore-argument">and use <code>_</code> parameter, e.g. <code>foo.map(_+1)</code> instead of <code>foo.map(x =&gt; x+1)</code></a></li>
</ul>
<p>It turns out, there are valid use cases for all of these! As degenerate "short names", using these Scala language features is basically governed by the same rules as any other name described in <a href="#long-names-vs-short-names">Long Names vs Short Names</a>. Thus, when things are <a href="#wider-scoped-names-should-be-longer">narrowly scoped</a>, are <a href="#more-used-names-should-be-shorter">heavily used</a>, or have lots of <a href="#names-with-source-context-should-be-shorter">source context</a> telling you what they do, using these features is totally fine. The sections below will elaborate on individual features.</p><h3 id="when-to-use-operators">When to use Operators?</h3>
<p>For now, I am treating the operators as a black-box, as I did in the section on <a href="#long-names-vs-short-names">Long Names vs Short Names</a>, and ignoring all the soft considerations e.g. "oh this operator reminds the user of this other mathematical operation" considerations which can be a whole separate post. Many operators have essentially no inherent meaning to begin with, and even those that do often lose it when faced with a novice audience. e.g. all the advanced mathematical symbols, now being used by people without a math degree.</p>
<p>Given that premise, this is probably bad</p>
<pre><code class="scala">def &lt;-+(arg: ...) = ...
</code></pre>
<p>Unless you're using <code>&lt;-+</code> in a whole lot of places, and a maintainer would have time to familiarize with it. On the other hand, it's not really any worse than</p>
<pre><code class="scala">def v(arg: ...) = ...
</code></pre>
<p>Which is also bad, unless you're planning on using <code>v</code> in a whole lot of places.</p>
<p>While in the Scala community operator names often get a bad rap, it's not really the fact that they're operators that's the problem. Even in crazy libraries with well-known too-many-operator-problems like SBT, replacing the operators with non-operators wouldn't really make things better. Similarly, while operators are hard to google, short names like <code>do</code> or <code>v</code> or <code>x</code> would be equally hard to google!</p>
<p>Although operators aren't worse than really-short names, you still shouldn't <a href="http://www.flotsam.nl/dispatch-periodic-table.html">go crazy with operators</a>. Operators are short names, and you should use them - or not use them - as you would very short alphanumeric names, following the guidelines above.</p>
<p>Since operators are just really-short names, they should be used in the same places really-short names would be used according to the logic in <a href="#long-names-vs-short-names">Long Names vs Short Names</a>.</p>
<ul>
  <li>
  <p><a href="#wider-scoped-names-should-be-longer">Wider-scoped names should be Longer</a>, and  operators should be avoided in scattered, globally available helpers. Prefer  to use them for names used in specific, narrow-ish contexts.</p></li>
  <li>
  <p><a href="#more-used-names-should-be-shorter">More-used Names should be Shorter</a>, and  operators are more justified when they are used a <em>lot</em>. If you find yourself  using a name or calling a method <em>multiple times per line</em>, over a large  number of lines, it could be worth making the name an operator.</p></li>
  <li>
  <p><a href="#dangerous-names-should-be-longer">Dangerous Names should be Longer</a>, and you  should never use an operator for something like "format hard disk" or  "drop databases". Obviously, almost all functionality can be "dangerous" when  used badly, but there is always functionality which is <em>inherently</em>  dangerous, even when used correctly. Avoid naming these using operators.</p></li>
  <li>
  <p><a href="#names-with-source-context-should-be-shorter">Names with Source-Context should be Shorter</a>,  and operators are acceptable in the case where someone "else" already tells  you what's going on. For example,  <a href="http://lihaoyi.github.io/Ammonite/#Ammonite-Ops">Ammonite-Ops</a> uses the <code>!</code>  operator to mean <code>Function1#apply</code>, which is slightly strange but acceptable  because when you are calling <code>!</code>, you always have the left-hand-side function  that tells you what it's doing: <code>ls!</code>, <code>rm!</code>, etc., so there shouldn't be  much confusion.</p></li>
  <li>
  <p><a href="#strongly-typed-names-should-be-shorter">Strongly-typed names should be Shorter</a>,  so avoid using operators with things that deal with <code>Any</code> or <code>Unit</code>, but  feel more free to use them in more strongly-typed code where you can be  confident the compiler can catch screw-ups.</p></li>
</ul>
<p>For more concrete examples where usage of operators is good or bad, check out the <a href="#case-studies">Case Studies</a> below!</p><h3 id="when-to-name-methods-apply">When to name methods "apply"?</h3>
<p>In Scala, you can define an <code>apply</code> method on an object that lets you use an object "directly" as if it was a function:</p>
<pre><code class="scala">object Foo{
  def apply(x: Int) = x + 1
}

Foo(2) // 3
</code></pre>
<p>This is already heavily used in the Scala standard library and in other places. For example, every collection uses <code>Collection.apply</code> as a factory method: <code>List(1, 2, 3)</code> is <code>List.apply(1, 2, 3)</code>, you have <code>Vector(&quot;hello&quot;, &quot;world&quot;)</code>, <code>Map(1 -&gt; 2, 3 -&gt; 4)</code>, and even non-collections e.g. <code>Future{...}</code>/ <code>Future.apply{...}</code> is how you create an asynchronous task.</p>
<p>In general, defining an <code>apply</code> method is basically like defining an ultimately short name: at <em>zero</em> characters it is the most convenient, but also provides <em>zero</em> information to a maintainer, who will have to rely on things like types and source-context to figure out what its for. Thus, the same considerations apply to "zero"-length <code>apply</code> methods as to any other short name:</p>
<ul>
  <li>
  <p><a href="#wider-scoped-names-should-be-longer">Wider-scoped names should be Longer</a>, this  equally applies to <code>apply</code> which is often defined on globally-available  companion objects. Thus, given that global names should be long, this should  discourage you from defining an <code>apply</code> method on a companion object unless  the following considerations are strong enough to outweigh this  discouragement.</p></li>
  <li>
  <p><a href="#more-used-names-should-be-shorter">More-used Names should be Shorter</a>: you  should be using the <code>apply</code> method a <em>lot</em>, more than any other method on the  object it's defined on. For example, <code>List.apply</code> to construct a <code>List(1, 2)</code>  is definitely the most heavily used method on the <code>List</code> companion object.  Similarly, <code>myArray.apply</code> to look up an index in an array <code>myArray(123)</code> is  definitely the most-used operation on <code>Array</code> instances.</p></li>
  <li>
  <p><a href="#dangerous-names-should-be-longer">Dangerous Names should be Longer</a>, and you  should never write an <code>apply</code> method someone could call "by accident".  Having a <code>myList.apply</code> to look up elements in a list is inefficient and  not commonly used, and as described in the section on  <a href="#dangerous-names-should-be-longer">Dangerous Names</a> it was probably a mistake to  make that the <code>apply</code> method on the <code>List</code> type. If an operation is risky,  don't stuff it under <code>apply</code></p></li>
  <li>
  <p><a href="#names-with-source-context-should-be-shorter">Names with Source-Context should be Shorter</a>,  and usages of an <code>apply</code> method always have the source-context of who-ever  you are calling <code>apply</code> on. For example, if you have a <code>Parser</code> class with  a single interesting <code>.parse</code> method, you could around calling  <code>myParser.parse(&quot;foo&quot;)</code> everywhere or you could equally decide to call the  method <code>myParser.apply</code> and call it via <code>myParser(&quot;foo&quot;)</code>. This isn't a  hard-and-fast rule, and many people are used to having single-abstract-method  interfaces since that's how things have worked in Java for 25 years, but  it's an option to consider when your class/object really-truly has a single  "obvious" operation to use that should be privileged over others.</p></li>
  <li>
  <p><a href="#strongly-typed-names-should-be-shorter">Strongly-typed names should be Shorter</a>,  so if your method is dealing with <code>Any</code>s or returning <code>Unit</code>, it probably  shouldn't be <code>apply</code> but instead of a longer more-descriptive name.</p></li>
</ul>
<p>In general, you should define an <code>apply</code> when there is a single, "obvious" thing that an object can do, that you expect to be used much more than other things that the object can do. Examples from the standard library include:</p>
<ul>
  <li><code>myArray(i)</code> being used to look up an <code>Array</code> with an index</li>
  <li><code>myMap(k)</code> being used to look up a <code>Map</code> by key</li>
  <li><code>List(...)</code> on the companion-object being used to construct <code>List</code>s.</li>
  <li><code>Future(...)</code> on the companion-object to construct <code>Future</code>s</li>
</ul>
<p>And examples from third-party libraries:</p>
<ul>
  <li><a href="https://github.com/lihaoyi/scala.rx">Scala.Rx</a> uses <code>Rx.apply</code> on the  companion to construct an <code>Rx</code>, and <code>myRx()</code> on an instance to extract  a value from an <code>Rx</code>. Both are by-far the most common things to want to do.</li>
  <li><a href="http://lihaoyi.github.io/Ammonite/#Ammonite-Ops">Ammonite-Ops</a> defines a  <code>read</code> object with a <code>read(...)</code> method to read in a file as a <code>String</code>, as  well as <code>read.lines</code> and <code>read.bytes</code> and <code>read.iter</code> methods to read it in  other formats. The assumption being that in most cases, you want to read in  <code>String</code>s. Similarly, there's <code>ls(...)</code> to list files in the most common,  basic case, and <code>ls.rec</code> and <code>ls.iter</code> for other less-used operations.</li>
</ul><h3 id="when-to-use-the--underscore-argument">When to use the _ Underscore Argument?</h3>
<p>This is fine</p>
<pre><code class="scala">val foo: List[Int] = ...
foo.map(_ + 1)
</code></pre>
<p>This has a name but it's pretty meaningless</p>
<pre><code class="scala">val foo: List[Int] = ...
foo.map(i =&gt; i + 1)
</code></pre>
<p>This name is longer, but not any less meaningless</p>
<pre><code class="scala">val foo: List[Int] = ...
foo.map(index =&gt; index + 1)
</code></pre>
<p>I mean, sure it's an <code>index</code>, but 99% of integers in your program are going to be indexes of something at some point, so it tells you nothing you don't already know!</p>
<p>This is probably an overkill</p>
<pre><code class="scala">val foo: List[Int] = ...
foo.map(fooIntValue =&gt; fooIntValue + 1)
</code></pre>
<p>And this is even more verbose and just as useless</p>
<pre><code class="scala">val foo: List[Int] = ...
def addOneToInt(int: Int) = int + 1
foo.map(addOneToInt)
</code></pre>
<p>In the end, there's a time and place for <code>_</code>: the ultimate short name. In many cases, what the <code>_</code> represents is obvious, and if the programmer already knows, you shouldn't need to keep repeating it in their face.</p>
<p>Like any other short name, <code>_</code> should be constrained by the same guidelines described above: it should only be used if the scope is <em>very</em> narrow, for something with a lot of source context around it that tells you what it is, and which you know the static type. You don't want it, for example, in multiline blocks:</p>
<pre><code class="scala">foo.foldLeft{
  _.doThingNow(
    123,
    &quot;hello&quot;,
    x =&gt; {
      ...
      ...
      ...
    }
    Enum.Thingy,
    _,
    verbose = true,
  )
}
</code></pre>
<p>In these cases you probably should use explicit names, even if short ones:</p>
<pre><code class="scala">foo.foldLeft{ (current, op) =&gt;
  current.doThingNow(
    123,
    &quot;hello&quot;,
    x =&gt; {
      ...
      ...
      ...
    }
    Enum.Thingy,
    op,
    verbose = true,
  )
}
</code></pre>
<p>Since in such large blocks the <code>_</code> is scoped widely enough that <a href="#wider-scoped-names-should-be-longer">Wider-scoped names should be Longer</a> applies.</p>
<p>Nevertheless, if your case satisfies all the criterion for for very short names:</p>
<ul>
  <li>It's scoped very tightly; preferably to a single line</li>
  <li>The static type is relatively tight (e.g. not <code>Any</code> or <code>AnyRef</code>)</li>
  <li>You can see from the surrounding code what the <code>_</code> could possibly mean.</li>
  <li>It's not dangerous (e.g. using <code>_</code> won't result in your disk being re-formatted)</li>
</ul>
<p>You shouldn't be afraid to use it. Just like the <code>*poke*</code> dinner-call people use in <a href="#human-languages">human languages</a>, if the future programmer already knows enough to know what "it" is, there's no need to belabor the point or elaborate.</p><h2 id="how-do-you-judge-names-in-a-library">How do you judge names in a library?</h2>
<p>So far, we've talked a lot about how you should write code based on expected usage patterns. How if you're going to be using code more heavily you can make more use of concise identifiers, whereas if you're going to be using something "once in a while" you probably should fall back to more verbose ways of doing things.</p>
<p>One question you might ask is: what about libraries? Those often tend to provide a nice to use, slightly-magical interface to downstream code using operators, but don't actually make use of the operators themselves. How do you know if you should have this sort of magic in the interface of your library?</p>
<p>To me, there are multiple answers to this:</p><h3 id="if-you-are-the-library-author">If you are the library author</h3>
<ul>
  <li>
  <p>Your library's "uses" are counted in an "expected" downstream project. If  the library is used in a bunch of different places and there are only at most  5 use-sites for an operator, it should be removed. If some projects use it  heavily (10s to 100s of uses) then it's fine, even if the library itself  never uses its own operators that much.</p></li>
  <li>
  <p>Your library's test suite <em>should</em> reflect expected usages. Your test suite  thus should make heavy enough use of your operators for them to be worth it,  as a proxy for how much you expect downstream code to use them. If you can't  find ways to use your operators in your test suite, I doubt anyone else can  either.</p></li>
</ul><h3 id="if-you-are-the-library-user">If you are the library user</h3>
<ul>
  <li>If <em>you</em> are the downstream project considering whether or not to use a  library, whether the library's use of operators is good for you (or not)  depends on how heavily <em>you</em> use the library! If a library makes heavy use  of operators, it'll only be good for <em>you</em> if you make heavy use  of the library.</li>
</ul>
<p>This is a slightly surprising: whether a library is good depends on your usage patterns, and not just on the library! But it's not entirely unexpected. After all, you as-a-user are the one who has to familiarize yourself to the library, and you-as-a-user are the one who gets confused when you see things you don't understand.</p>
<p>That means that for a library making heavy use of operators, it could be a pretty lousy library to use "once in a while" but simultaneously a great library to use "heavily"! For example, as a casual user of Scalaz or Shapeless, you may never see enough of the operator-driven APIs to familiarize yourself, and thus may always be somewhat uncomfortable without reaping much benefits. On the other hand, if you are using it heavily, the discomfort will go away with familiarity and you'll get all of the gain with none of the downsides of casual use!</p>
<p>This itself is an interesting message to library authors: how you design your API should depend on how heavily you expect people to use it.</p>
<ul>
  <li>
  <p>If you expect people to use it lightly, calling one or two functions in  random parts of their program, you should provide a "basic" API without magic  even if it means there's some boilerplate</p></li>
  <li>
  <p>If you expect people to use it heavily, either in one part of their program  (like <a href="#positive-parser-combinator-example">FastParse</a>) or throughout their  program (like <a href="#case-study-scalaz">Scalaz</a>) you should provide a convenient,  boilerplate-free API even if it means making things shorter or using  operators.</p></li>
</ul><h2 id="case-studies">Case Studies</h2>
<p>The best way to learn is to look at examples. Especially in this kind of soft subject, where everything is a tradeoff, examples help make things concrete and let you make future judgements based on other people's past experiences. Apart from the small examples scattered throughout the document above, here are a few meaty examples that cross section-boundaries and compare multiple competing projects trying to do the same thing.</p><h3 id="case-study-parser-combinators">Case Study: Parser Combinators</h3>
<p>Many parser-combinator libraries let the programmer define their parser using short operator-names. Here's two examples:</p><h4 id="positive-parser-combinator-example">Positive Parser Combinator Example</h4>
<p>FastParse lets you write:</p>
<pre><code class="scala">val number: P[Int] = P( CharIn(&#39;0&#39;to&#39;9&#39;).rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )
</code></pre>
<p>Here, we have a plethora of short names! We have the <code>P</code> type and function, the <code>.rep</code> method, the <code>.!</code> method, the <code>|</code> and <code>~</code> and <code>~/</code> methods. This clearly uses a lot of operators. And yet, in most of the Scala community, this is considered "ok". Why is that?</p>
<p>The answer comes down to the FastParse library syntax satisfying many of the rules we specified above regarding when-to-use-short-names. In particular:</p>
<ul>
  <li>These names are usually imported and available for very narrow parts of your  program: basically where your parser-grammar is defined and no-where else</li>
  <li>Each name is used a <em>lot</em>: in this trivial example we have 4 <code>~</code>s, 3 <code>~/</code>s,  3 <code>.rep</code>s, 3 <code>.!</code>s, and 12 <code>P</code>s. In a larger example, you get dozens of uses</li>
  <li>Each method is strongly-typed and returns a parser (or <code>P[_]</code>) of some  statically-known type.</li>
</ul>
<p>In aggregate, what does this mean? This means that a maintainer who comes across your code in future will see crazy operators, but a very consistent use of the same few crazy operators, constrained to a narrow part of your code. They won't be bumping into operators in random corners of your codebase, and after learning a relatively-small number of operators would be able to figure out how things work.</p>
<p>Furthermore, even if they do get confused, the fact that the operations are all relatively strongly-typed means that even if they fumble and make a mistake, it's likely the compiler will tell them what went wrong with reasonable accuracy.</p><h4 id="negative-parser-combinator-example">Negative Parser Combinator Example</h4>
<p>It's possible to mis-use operators, even in parser-combinator libraries. Here's the list of operations from the old scala-parser-combinators project:</p>
<pre><code class="scala">*[U &gt;: T](sep: ⇒ Parser[(U, U) ⇒ U]): Parser[U]
*: Parser[List[T]]
+: Parser[List[T]]
&lt;~[U](q: ⇒ Parser[U]): Parser[T]
&gt;&gt;[U](fq: (T) ⇒ Parser[U]): Parser[U]
?: Parser[Option[T]]
^?[U](f: PartialFunction[T, U]): Parser[U]
^?[U](f: PartialFunction[T, U], error: (T) ⇒ String): Parser[U]
^^[U](f: (T) ⇒ U): Parser[U]
^^^[U](v: ⇒ U): Parser[U]
andThen[A](g: (ParseResult[T]) ⇒ A): (Input) ⇒ A
append[U &gt;: T](p0: ⇒ Parser[U]): Parser[U]
compose[A](g: (A) ⇒ Input): (A) ⇒ ParseResult[T]
filter(p: (T) ⇒ Boolean): Parser[T]
flatMap[U](f: (T) ⇒ Parser[U]): Parser[U]
into[U](fq: (T) ⇒ Parser[U]): Parser[U]
map[U](f: (T) ⇒ U): Parser[U]
named(n: String): Parser.this.type
toString(): String
withErrorMessage(msg: String): Parser[T]
withFailureMessage(msg: String): Parser[T]
withFilter(p: (T) ⇒ Boolean): Parser[T]
|[U &gt;: T](q: ⇒ Parser[U]): Parser[U]
|||[U &gt;: T](q0: ⇒ Parser[U]): Parser[U]
~[U](q: ⇒ Parser[U]): Parser[~[T, U]]
~![U](p: ⇒ Parser[U]): Parser[~[T, U]]
~&gt;[U](q: ⇒ Parser[U]): Parser[U]
</code></pre>
<p>There's a lot of stuff in there! While FastParse gets by with five operators <code>~</code> <code>~/</code> <code>|</code> <code>!</code> <code>?</code>, the old scala-parser-combinators project has fifteen! Many of them are redundant, for example <code>^^</code> is equivalent to <code>map</code>, and <code>&gt;&gt;</code> is equivalent to <code>flatMap</code>, and <code>*</code> for the <code>rep</code> function which is not listed here because it's a function rather than a method.</p>
<p>While it's easy to complain, what does this mean concretely? This means that a programmer looking into a scala-parser-combinator codebase is very likely to bump into cryptic operators they're not familiar with, that are only used in one or two places throughout the codebase. Things like <code>^^^</code> or <code>|||</code> or <code>^?</code> aren't likely to be widely used, and even "common" operators like <code>^^</code> or <code>&gt;&gt;</code> or <code>.*</code> or <code>.+</code> are going to be used less-than-they-could-be since they're competing with alternative names <code>map</code> <code>flatMap</code> <code>rep</code> <code>rep1</code>. This makes these operator names fail the criterion I set above for writing short names, and they probably should have just fallen back to providing only-alphanumeric methods for most of these less-used operations.</p><h3 id="case-study-scalaz">Case Study: Scalaz</h3>
<p>The <a href="https://github.com/scalaz/scalaz">Scalaz</a> library <a href="http://eed3si9n.com/scalaz-cheat-sheet">uses operators heavily</a> for many things:</p>
<pre><code class="scala">List(1, 2) |+| List(3) assert_=== List(1, 2, 3)
</code></pre>
<p>And some people complain about the crypticness of <code>|+|</code> or <code>&lt;*&gt;</code> operators. Nevertheless, although if you look at Scalaz casually you could be scared off, there are mitigating factors that make this less sketchy than it initially seems:</p>
<p><strong>The same operators are used for all sorts of different things</strong>: strings, lists, options, and countless other data structures.</p>
<pre><code class="scala"><br/>@ import scalaz._, Scalaz._
import scalaz._, Scalaz._

@ List(1, 2, 3) |+| List(4, 5, 6)
res1: List[Int] = List(1, 2, 3, 4, 5, 6)

@ &quot;one&quot; |+| &quot;two&quot;
res2: String = onetwo

@ (None: Option[String]) |+| (Some(&quot;string&quot;): Option[String])
res3: Option[String] = Some(&quot;string&quot;)

@ (Some(&quot;123&quot;): Option[String]) |+| (Some(&quot;string&quot;): Option[String])
res4: Option[String] = Some(&quot;123string&quot;)
</code></pre>
<p>Thus the operator, while cryptic, would be widely used throughout your code.</p>
<p><strong>If you use Scalaz heavily you can easily find 100s of usages within your program</strong>, often several on the same line!</p>
<pre><code class="scala">for {
  e1 &lt;- &quot;event 1 ok&quot;.right
  e2 &lt;- &quot;event 2 failed!&quot;.left[String]
  e3 &lt;- &quot;event 3 failed!&quot;.left[String]
} yield (e1 |+| e2 |+| e3)
</code></pre>
<p>That is definitely enough density-of-usage that the benefits from having the operators be short and concise pays off, and giving them long names would make your program considerably more verbose. You certainly use Scalaz's operators much more than you would, say, <a href="#negative-dispatch">make HTTP requests</a>, and so use of short operators are much more justified.</p>
<p><strong>Scalaz's operators are all pretty strongly typed</strong>. For example, you may find it easy to confuse the <code>&lt;*</code> <code>*&gt;</code> and <code>&lt;*&gt;</code> operators, even after you know what they do, since they look so similar! Nevertheless, you have the type signatures to fall back on:</p>
<pre><code class="scala">final class ApplyOps[F[_], A](self: F[A]){
  def *&gt;[B](fb: F[B]): F[B]
  def &lt;*[B](fb: F[B]): F[A]
  def &lt;*&gt;[B](fb: F[A =&gt; B]): F[B]
}
</code></pre>
<p>Which should make it pretty clear that <code>*&gt;</code> seems to be taking a <code>F[A]</code> and <code>F[B]</code>, throwing away the <code>A</code>, and keeping the <code>B</code>.<code>&lt;*</code> does the opposite, and <code>&lt;*&gt;</code> seems to take in some kind of transformer-function that turns the <code>A</code> into the <code>B</code> using that function.</p>
<p>While strong types doesn't mean names don't matter, it <em>does</em> mean you can lean more heavily on the types than you would in a weakly-typed scenario dealing with <code>Any</code>s and <code>Unit</code>s with side-effects. Furthermore, even if you're likely to screw it up, the compiler will catch you:</p>
<pre><code class="scala">@ (None: Option[String]) *&gt; (Some(&quot;string&quot;): Option[String])
res6: Option[String] = None
@ (None: Option[String]) &lt;*&gt; (Some(&quot;string&quot;): Option[String])
Main.scala:2159: type mismatch;
 found   : Option[String]
 required: Option[String =&gt; ?]
(None: Option[String]) &lt;*&gt; (Some(&quot;string&quot;): Option[String])
                                          ^
Compilation Failed
</code></pre>
<p>So that adds an additional safety net that makes the operator-names less dangerous.</p>
<hr/>
<p>Overall, while Scalaz gets a lot of flak for heavy use of operators, that usage is justified under heavy usage patterns. While it has not-a-small-number of operators and other magic (extension methods, implicit conversions, ...) you are expected to make heavy use of these operators throughout your program, and can expect someone working in such a codebase to become familiar with them.</p>
<p>Furthermore, the density of usage is enough that you often have multiple operators on the same line, which makes it well-worth-while to keep them short! Lastly, the fact that the operators are all pretty strongly-typed means that even if the names are meaningless, you can lean on the types and the compiler to help you do the right thing.</p>
<p>Note that a lot of this depends on <em>usage patterns</em> in <em>your</em> codebase, and is <em>not</em> inherent to Scalaz itself! If you use Scalaz in a few places scattered throughout your codebase, the benefits of operators go way down and the costs (in terms of confusion due to unfamiliarity) <em>go up</em>. It's entirely reasonable for people to have totally different opinions of the library depending on their usage pattern, and to maximize benefit you should probably go all-in with Scalaz, or use it not-at-all.</p><h3 id="case-study-http">Case Study: HTTP</h3>
<p>Here, we're going to compare the APIs of two different libraries for doing the same thing: <a href="https://github.com/scalaj/scalaj-http">Scalaj-HTTP</a> and <a href="http://dispatch.databinder.net/Dispatch.html">Databinder Dispatch</a>. Although they do the same thing, they present pretty different APIs to a developer.</p><h4 id="positive-scalaj-http">Positive: Scalaj-HTTP</h4>
<p>Scalaj-HTTP is a great example of a library that provides an awesome API for newbies:</p>
<pre><code class="scala">import scalaj.http._

val response = Http(&quot;http://foo.com/search&quot;).param(&quot;q&quot;,&quot;monkeys&quot;).asString
response.body
response.code
response.headers
response.cookies

Http(url).postMulti(MultiPart(&quot;photo&quot;, &quot;headshot.png&quot;, &quot;image/png&quot;, fileBytes)).asString
</code></pre>
<p>No cryptic operators to worry about. Everything is just an object with methods, and the last method <code>.asString</code> or similar (there are equivalents for binary responses) gives you your result. The methods operating on these objects aren't particularly concise, but they're not that long either and you can probably guess what they do just from the name, and probably be correct.</p><h4 id="negative-dispatch">Negative: Dispatch</h4>
<p>In contrast, Dispatch is a library that is <a href="http://www.flotsam.nl/dispatch-periodic-table.html">notorious for over-using operators</a>. Although it's gotten better in recent years, it still uses them far more than necessary. For example, adding a POST parameter to a request involves a mysterious <code>&lt;&lt;</code> operator:</p>
<pre><code class="scala">val myRequest = url(&quot;http://example.com/some/path&quot;)
def myPostWithParams = myRequest &lt;&lt; Map(&quot;key&quot; -&gt; &quot;value&quot;)
def myPut = myRequest &lt;&lt;&lt; myFile
</code></pre>
<p>While <code>&lt;&lt;</code> does save keystrokes over <code>.param</code>, whether or not its a good idea or not comes down to our <a href="#long-names-vs-short-names">earlier considerations on names</a>: are the usage patterns of Dispatch heavy enough to warrent operators for all these methods? After all, we found that for <a href="#case-study-parser-combinators">Parser Combinators</a>, with heavy usage operators can be justified.</p>
<p>Ultimately, my judgement is that it isn't: even in the heaviest HTTP-request-making environment I can think of - client-server front-end web development - HTTP requests tended to happen less than once or twice per file. You certainly make HTTP requests much less than you use operators from <a href="#case-study-scalaz">Scalaz</a>, for exampe. My judgement is that this usage density is less than the threshold for which I would consider operator-powered APIs valid.</p><div><hr /><div style="color: rgb(158, 167, 174);">Updated <a href="https://github.com/lihaoyi/blog/commit/abba401c95a3d2d79d5caee9c61eb8c794d6d0be">2016-03-04 </a><a href="https://github.com/lihaoyi/blog/commit/26e2aed6c343f5ad1ad7d97ddb1fdc0a5ae5486d">2016-02-26 </a><a href="https://github.com/lihaoyi/blog/commit/60722660f0f0d2d6345edd7fcd853bf59d0e684c">2016-02-26 </a><a href="https://github.com/lihaoyi/blog/commit/42224dfecf02bb8bfdbc7b6c6808113584699a04">2016-02-24 </a><a href="https://github.com/lihaoyi/blog/commit/05e7f40395257a8279d8d88f4a2351f18d361109">2016-02-22 </a><a href="https://github.com/lihaoyi/blog/commit/a346d60f325674e1f195e717b7d320b1d5e62434">2016-02-22 </a><a href="https://github.com/lihaoyi/blog/commit/a8d12dc900428d44aaf34397141f6f75a64b9342">2016-02-22 </a><a href="https://github.com/lihaoyi/blog/commit/2681c352390af9f0cbe617ac56d8ded6ee72255a">2016-02-22 </a><a href="https://github.com/lihaoyi/blog/commit/5129386c3d21f574a83640bb39645c9899f0e3a2">2016-02-22 </a><a href="https://github.com/lihaoyi/blog/commit/d63be1ea127fc18787277aee51052fcd3cae8a90">2016-02-22 </a><a href="https://github.com/lihaoyi/blog/commit/d37784a1302eafd80a6a07ab573092bb16c25538">2016-02-22 </a></div></div><div id="disqus_thread"></div><script>
      /**
      * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
      * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
      */

      var disqus_config = function () {
      this.page.url = "http://www.lihaoyi.com/post/StrategicScalaStyleConcisenessNames.html"; // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "Strategic Scala Style: Conciseness & Names"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };

      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');

      s.src = '//lihaoyi.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
  </script></div><div class=" cache6e734f883e5a972fd8c15f0a7a2b05ec-WideStyles-footer cache6e734f883e5a972fd8c15f0a7a2b05ec-Styles-footer">Last published 2016-03-04</div></body></html>